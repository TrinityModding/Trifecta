// automatically generated by the FlatBuffers compiler, do not modify

package me.hydos.trifecta.flatbuffers.Titan.Shader;

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.Table;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

@SuppressWarnings("unused")
public final class SlotMap extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_23_3_3(); }
  public static SlotMap getRootAsSlotMap(ByteBuffer _bb) { return getRootAsSlotMap(_bb, new SlotMap()); }
  public static SlotMap getRootAsSlotMap(ByteBuffer _bb, SlotMap obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public SlotMap __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public String slotName() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer slotNameAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer slotNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  public SlotMapping slotValues(int j) { return slotValues(new SlotMapping(), j); }
  public SlotMapping slotValues(SlotMapping obj, int j) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int slotValuesLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }
  public SlotMapping.Vector slotValuesVector() { return slotValuesVector(new SlotMapping.Vector()); }
  public SlotMapping.Vector slotValuesVector(SlotMapping.Vector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  public int bool1() { int o = __offset(8); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  public int bool2() { int o = __offset(10); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  public int bool3() { int o = __offset(12); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  public int slotIndex() { int o = __offset(14); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  public long offset() { int o = __offset(16); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }

  public static int createSlotMap(FlatBufferBuilder builder,
      int slotNameOffset,
      int slotValuesOffset,
      int bool1,
      int bool2,
      int bool3,
      int slotIndex,
      long offset) {
    builder.startTable(7);
    SlotMap.addOffset(builder, offset);
    SlotMap.addSlotValues(builder, slotValuesOffset);
    SlotMap.addSlotName(builder, slotNameOffset);
    SlotMap.addSlotIndex(builder, slotIndex);
    SlotMap.addBool3(builder, bool3);
    SlotMap.addBool2(builder, bool2);
    SlotMap.addBool1(builder, bool1);
    return SlotMap.endSlotMap(builder);
  }

  public static void startSlotMap(FlatBufferBuilder builder) { builder.startTable(7); }
  public static void addSlotName(FlatBufferBuilder builder, int slotNameOffset) { builder.addOffset(0, slotNameOffset, 0); }
  public static void addSlotValues(FlatBufferBuilder builder, int slotValuesOffset) { builder.addOffset(1, slotValuesOffset, 0); }
  public static int createSlotValuesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSlotValuesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addBool1(FlatBufferBuilder builder, int bool1) { builder.addByte(2, (byte) bool1, (byte) 0); }
  public static void addBool2(FlatBufferBuilder builder, int bool2) { builder.addByte(3, (byte) bool2, (byte) 0); }
  public static void addBool3(FlatBufferBuilder builder, int bool3) { builder.addByte(4, (byte) bool3, (byte) 0); }
  public static void addSlotIndex(FlatBufferBuilder builder, int slotIndex) { builder.addByte(5, (byte) slotIndex, (byte) 0); }
  public static void addOffset(FlatBufferBuilder builder, long offset) { builder.addInt(6, (int) offset, (int) 0L); }
  public static int endSlotMap(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public SlotMap get(int j) { return get(new SlotMap(), j); }
    public SlotMap get(SlotMap obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
  public SlotMapT unpack() {
    SlotMapT _o = new SlotMapT();
    unpackTo(_o);
    return _o;
  }
  public void unpackTo(SlotMapT _o) {
    String _oSlotName = slotName();
    _o.setSlotName(_oSlotName);
    SlotMappingT[] _oSlotValues = new SlotMappingT[slotValuesLength()];
    for (int _j = 0; _j < slotValuesLength(); ++_j) {_oSlotValues[_j] = (slotValues(_j) != null ? slotValues(_j).unpack() : null);}
    _o.setSlotValues(_oSlotValues);
    int _oBool1 = bool1();
    _o.setBool1(_oBool1);
    int _oBool2 = bool2();
    _o.setBool2(_oBool2);
    int _oBool3 = bool3();
    _o.setBool3(_oBool3);
    int _oSlotIndex = slotIndex();
    _o.setSlotIndex(_oSlotIndex);
    long _oOffset = offset();
    _o.setOffset(_oOffset);
  }
  public static int pack(FlatBufferBuilder builder, SlotMapT _o) {
    if (_o == null) return 0;
    int _slotName = _o.getSlotName() == null ? 0 : builder.createString(_o.getSlotName());
    int _slotValues = 0;
    if (_o.getSlotValues() != null) {
      int[] __slotValues = new int[_o.getSlotValues().length];
      int _j = 0;
      for (SlotMappingT _e : _o.getSlotValues()) { __slotValues[_j] = SlotMapping.pack(builder, _e); _j++;}
      _slotValues = createSlotValuesVector(builder, __slotValues);
    }
    return createSlotMap(
      builder,
      _slotName,
      _slotValues,
      _o.getBool1(),
      _o.getBool2(),
      _o.getBool3(),
      _o.getSlotIndex(),
      _o.getOffset());
  }
}

